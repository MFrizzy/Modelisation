\documentclass{article}

\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{hyperref}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{Tkz-Tab}
\usepackage{wrapfig}
\usepackage{verbatim}
\usepackage{array}

\begin{document}

\title{Gestion de flux dans le réseau
	\smallbreak
	TD n\degre4
	\smallbreak
	Modélisation mathématique
	\smallbreak
	Q4}
\author{Sibylle Roux \and Juliette Arazo \and Nicolas Le Gallo \and Tanguy Thomas}


\maketitle

\newpage

\tableofcontents

\newpage

\part{Etude statistique des temps interarrivés}

\section{Etude statistique des temps interarrivés pour tous les serveurs}

\subsection{Indicateurs de position et de dispersion}

\begin{center}
\begin{tabular}{cccc}
\hline
\hline
Min & Max & Moyenne & Médiane \\
\hline
0.01 & 21.98 & 2.9 & 1.95 \\
\hline
\hline
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{ccc}
\hline
\hline
Variance & Ecart-type & Etendue \\
\hline
8.73 & 2.95 & 22 \\
\hline
\hline
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{ccc}
\hline
\hline
Q1 & Q2 & Interquartile \\
\hline
0.76 & 4.09 & 3.33 \\
\hline
\hline
\end{tabular}
\end{center}

\subsection{Fonction de répartition}
\begin{center}
\includegraphics[width=425px]{img/repart.png}
\end{center}
\paragraph{}
Ce graphique nous montre que la moitié des temps inter-arrivées sont inférieurs ou égaux à 2 secondes.

\subsection{Histogramme}

\subsubsection{Histogramme avec classes isoamplitudes}
\begin{center}
\includegraphics[width=425px]{img/H_isoa.png}
\end{center}
\paragraph{}
Cet histogramme indique la concentration des données au sein des différentes classes de même amplitudes. 
On remarque à l’aide de cet histogramme que les valeurs sont principalement concentrées dans la première classe, qui regroupe les temps d'inter-arrivées de 0 à 2,15 secondes. Ensuite la concentration des valeurs est divisée d’environ par deux pour chacunes des classes suivantes.

\subsubsection{Histogramme avec classes isofréquences}
\begin{center}
\includegraphics[width=425px]{img/H_isof.png}
\end{center}
\paragraph{}
Cet histogramme indique la concentration des données au sein des différentes classes de même fréquence.
Nous visualisons rapidement la zone creuse lorsque les temps d’inter-arrivées dépassent les 6,30secondes.

\part{Etude statistique des temps de service}

\section{Indicateurs de position et de dispersion}

\begin{tabular}{|c|c|c|c|}
  \hline
  Indicateurs & Serveur 1 & Serveur 2 & Serveur 3 \\
  \hline
  Minimum & 0.01 & 0.04 & 0.01 \\
  Maximum & 134 & 88.9 & 68.6 \\
  Etendue & 134 & 88.8 & 68.6 \\
  \hline
  Moyenne & 15.5 & 10.6 & 6.27 \\
  Médiane & 11.5 & 6.82 & 4.35 \\
  \hline
  Q1 & 5.05 & 3.29 & 1.75 \\
  Q3 & 21.9 & 13.9 & 8.36 \\
  IQ & 16.8 & 10.6 & 6.61 \\
  \hline
  Ecart-Type & 15 & 11.3 & 6.85 \\
  Variance & 225 & 127 & 46.9 \\
  \hline
\end{tabular}

\section{Fonctions de répartition}

\subsection{Serveur 1}
\begin{center}
\includegraphics[width=425px]{img/S1_repart.png}
\end{center}
\paragraph{}
Ce graphique nous montre que la moitié des temps inter-arrivées au serveur 1 sont inférieurs ou égaux à 12 secondes.

\subsection{Serveur 2}
\begin{center}
\includegraphics[width=425px]{img/S2_repart.png}
\end{center}
\paragraph{}
Ce graphique nous montre que la moitié des temps inter-arrivées au serveur 2 sont inférieurs ou égaux à 7 secondes.

\subsection{Serveur 3}
\begin{center}
\includegraphics[width=425px]{img/S3_repart.png}
\end{center}
\paragraph{}
Ce graphique nous montre que la moitié des temps inter-arrivées au serveur 3 sont inférieurs ou égaux à 4,3 secondes.

\section{Histogrammes}

\subsection{Serveur 1}
\begin{center}
\includegraphics[width=425px]{img/S1_histo.png}
\end{center}
\paragraph{}
La zone creuse est présente pour les temps d’inter-arrivées supérieurs ou égaux à 34 secondes.

\subsection{Serveur 2}
\begin{center}
\includegraphics[width=425px]{img/S2_histo.png}
\end{center}
\paragraph{}
La zone creuse est présente pour les temps d’inter-arrivées supérieurs ou égaux à 24 secondes.

\subsection{Serveur 3}
\begin{center}
\includegraphics[width=425px]{img/S3_histo.png}
\end{center}
\paragraph{}
La zone creuse est présente pour les temps d’inter-arrivées supérieurs ou égaux à 15 secondes.

\part{Ajustement graphique à des lois mathématiques}

\section{Estimation des paramètres}

\subsection{Loi normale}
\paragraph{}
La loi normale $X \sim N(\mu,\sigma)$ s'exprime en fonction de l'esperance $\mu$ ainsi que de l'écart-type $\sigma$. On associe donc l'espérance à la moyenne des temps d'attentes/temps interarrivés.

\subsection{Loi uniforme}
\paragraph{}
La loi uniforme dépend de 2 paramètres : $a$ et $b$ qui correspondant à l'intervalle $[a,b]$ sur laquelle est définie la loi uniforme. On associe donc $a$ au minimum et $b$ au maximum des temps d'attentes/temps interarrivés.

\subsection{Loi exponentielle}
\paragraph{}
La loi exponentielle dépend d'un seul paramètre : $\lambda$.
Or on sait que pour une loi exponentielle $X$ :
\begin{align}
E(X) & =\frac{1}{\lambda} \\
V(X) & =\frac{1}{\lambda^2}
\intertext{Donc}
\lambda & =\frac{1}{E(X)} \\
\lambda & =\frac{1}{\sqrt{V(X)}} \\
&= \frac{1}{\sigma}
\end{align}
On en déduit déjà que pour qu'une la moyenne doit être égale à l'écart type pour que les temps de services soient les réalisations d'une loi exponentielle.

\section{Tous les serveurs}

\subsection{Superposition des fonctions de répartition}
\begin{center}
\includegraphics[width=300px]{img/repartitions.png}
\end{center}
\paragraph{}
Les courbes des fonctions de répartition de la loi uniforme et de la loi normale ne correspondent pas à celle des serveurs car l’une se comporte comme une droite et l’autre ne démarre pas avec sa vitesse d’accroissement maximale.
Les courbes des fonctions de répartition empirique et de la loi exponentielle se superposent et ressemblent fortement à la fonction de répartition des serveurs.


\subsection{Superposition des fonctions de densité et de l'histogramme}
\begin{center}
\includegraphics[width=300px]{img/densite.png}
\end{center}
\paragraph{}
Une loi uniforme a une étendue proche de 0 or on remarque que l’étendu des temps de services est largement supérieure à 0. On en conclut donc l’on ne peut modéliser les temps de services par une loi uniforme. On remarque aussi que la courbe de la loi normale n’est pas du tout proche de l’histogramme des temps de service, par contre la courbe de la fonction de densité de la loi exponentielle s’approche de la forme de l’histogramme. De plus on remarque que la moyenne est presque égale à son écart-type, ce qui est une des caractéristiques de la loi exponentielle.

\subsection{Propriété d'absense de mémoire}
\begin{center}
\includegraphics[width=300px]{img/S1_mem.png}
\end{center}

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
  \hline
  Indicateurs & Moyenne & Mediane & Variance & Ecart-type & Etendue \\
  \hline
  Temps interarrivés & 2.9 & 1.95 & 8.73 & 2.95 & 22 \\
  Temps interarrivés après 1s & 2.92 & 2.06 & 8.79 & 2.96 & 21 \\
  Différence & 0.01 & 0.11 & 0.05 & 0.01 & 1 \\
  \hline
\end{tabular}
\end{center}

\paragraph{}
Nous remarquons aisément que ces deux histogrammes sont similaires, ce qui signifie que la différence entre les temps de services et les temps de services-1 seconde est proche de 0. Donc on en déduit qu’il y a une absence de mémoire.

\section{Serveur 1}

\subsection{Superposition des fonctions de répartition}
\begin{center}
\includegraphics[width=300px]{img/S1_repartitions.png}
\end{center}
\paragraph{}
On remarque que la fonction de répartition de la loi exponentielle est celle qui correspond le plus pour représenter la répartition empirique des temps de service.

\subsection{Superposition des fonctions de densité et de l'histogramme}
\begin{center}
\includegraphics[width=300px]{img/S1_densite.png}
\end{center}
\paragraph{}
Une loi uniforme a une étendue proche de 0 or on remarque que l’étendu des temps de services est largement supérieure à 0. On en conclut donc l’on ne peut modéliser les temps de services par une loi uniforme. On remarque aussi que la courbe de la loi normale n’est pas du tout proche de l’histogramme des temps de service, par contre la courbe de la fonction de densité de la loi exponentielle s’approche de la forme de l’histogramme. De plus on remarque que la moyenne est presque égale à son écart-type, ce qui est une des caractéristiques de la loi exponentielle.

\subsection{Propriété d'absense de mémoire}
\begin{center}
\includegraphics[width=300px]{img/S1_mem.png}
\end{center}

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
  \hline
  Indicateurs & Moyenne & Mediane & Variance & Ecart-type & Etendue \\
  \hline
  Temps d'attentes & 15.50 & 11.49 & 224.59 & 14.98 & 133.89 \\
  Temps d'attentes après 1s & 15.56 & 11.41 & 223.15 & 14.93 & 132.78 \\
  Différence & 0.06 & 0.08 & 1.44 & 0.04 & 1.11 \\
  \hline
\end{tabular}
\end{center}

\paragraph{}
Nous remarquons aisément que ces deux histogrammes sont similaires, ce qui signifie que la différence entre les temps de services et les temps de services-1 seconde est proche de 0. Donc on en déduit qu’il y a une absence de mémoire.

\section{Serveur 2}

\subsection{Superposition des fonctions de répartition}
\begin{center}
\includegraphics[width=300px]{img/S2_repartitions.png}
\end{center}
\paragraph{}
On remarque que la fonction de répartition de la loi exponentielle est celle qui correspond le plus pour représenter la répartition empirique des temps de service.

\subsection{Superposition des fonctions de densité et de l'histogramme}
\begin{center}
\includegraphics[width=300px]{img/S2_densite.png}
\end{center}
\paragraph{}
Une loi uniforme a une étendue proche de 0 or on remarque que l’étendu des temps de services est largement supérieure à 0. On en conclut donc l’on ne peut modéliser les temps de services par une loi uniforme. On remarque aussi que la courbe de la loi normale n’est pas du tout proche de l’histogramme des temps de service, par contre la courbe de la fonction de densité de la loi exponentielle s’approche de la forme de l’histogramme. De plus on remarque que la moyenne est presque égale à son écart-type, ce qui est une des caractéristiques de la loi exponentielle.

\subsection{Propriété d'absense de mémoire}
\begin{center}
\includegraphics[width=300px]{img/S2_mem.png}
\end{center}

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
  \hline
  Indicateurs & Moyenne & Mediane & Variance & Ecart-type & Etendue \\
  \hline
  Temps d'attentes & 10.56 & 6.82 & 126.84 & 11.26 & 88.85 \\
  Temps d'attentes après 1s & 10.65 & 7.08 & 128.22 & 11.32 & 87.88 \\
  Différence & 0.08 & 0.26 & 1.38 & 0.06 & 0.97 \\
  \hline
\end{tabular}
\end{center}

\paragraph{}
Nous remarquons aisément que ces deux histogrammes sont similaires, ce qui signifie que la différence entre les temps de services et les temps de services-1 seconde est proche de 0. Donc on en déduit qu’il y a une absence de mémoire.

\section{Serveur 3}

\subsection{Superposition des fonctions de répartition}
\begin{center}
\includegraphics[width=300px]{img/S3_repartitions.png}
\end{center}
\paragraph{}
On remarque que la fonction de répartition de la loi exponentielle est celle qui correspond le plus pour représenter la répartition empirique des temps de service.

\subsection{Superposition des fonctions de densité et de l'histogramme}
\begin{center}
\includegraphics[width=300px]{img/S3_densite.png}
\end{center}
\paragraph{}
Une loi uniforme a une étendue proche de 0 or on remarque que l’étendu des temps de services est largement supérieure à 0. On en conclut donc l’on ne peut modéliser les temps de services par une loi uniforme. On remarque aussi que la courbe de la loi normale n’est pas du tout proche de l’histogramme des temps de service, par contre la courbe de la fonction de densité de la loi exponentielle s’approche de la forme de l’histogramme. De plus on remarque que la moyenne est presque égale à son écart-type, ce qui est une des caractéristiques de la loi exponentielle.

\subsection{Propriété d'absense de mémoire}
\begin{center}
\includegraphics[width=300px]{img/S3_mem.png}
\end{center}

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
  \hline
  Indicateurs & Moyenne & Mediane & Variance & Ecart-type & Etendue \\
  \hline
  Temps d'attentes & 6.27 & 4.35 & 46.88 & 6.84 & 68.58 \\
  Temps d'attentes après 1s & 6.41 & 4.45 & 48.19 & 6.94 & 67.57 \\
  Différence & 0.14 & 0.10 & 1.30 & 0.09 & 1.01 \\
  \hline
\end{tabular}
\end{center}

\paragraph{}
Nous remarquons aisément que ces deux histogrammes sont similaires, ce qui signifie que la différence entre les temps de services et les temps de services-1 seconde est proche de 0. Donc on en déduit qu’il y a une absence de mémoire.

\part{Conclusion}

\paragraph{}
A partir de l’étude des données fournies et grâce aux comparaisons avec des lois connues, nous avons pu déterminer que la loi exponentielle, de paramètre unique ($\lambda = \frac{1}{moyenne}$)  était celle qui se rapprochait le plus de ce qu’il se passe en réalité dans les serveurs, et donc qu’elle est la plus adaptée pour des simulations. En effet, lorsqu’on compare la fonction de répartition de la loi exponentielle à celles empiriques, et lorsqu’on compare la densité de la loi exponentielle avec les histogrammes des données, on remarque de très fortes ressemblances, beaucoup plus que pour la loi uniforme ou la loi normale. 
\paragraph{}     
De plus, on a remarqué empiriquement que le temps d'attente moyen ne changeait pas en fonction du temps qu'on avait déjà passé à  attendre. Par exemple pour un temps moyen de 5s, après 2s passées à attendre le temps moyen d'attente est toujours de 5s. Or, la loi exponentielle est une loi sans mémoire, c'est à dire que ses valeurs ne sont pas influencées par la valeurs précédentes, ce qui colle parfaitement avec le comportement de nos données.
\paragraph{}
Nous préconisons donc l’utilisation de cette loi exponentielle pour la reproduction de données réalistes et fiables dans l’optique d’une étude et d’une analyse poussées du système.

\newpage
\appendix

\section{Etude statistique des temps interarrivés}

\subsection{Indicateurs de position et de dispersion}
\begin{verbatim}
// Extraction des temps inter-arrivées
t_ia = data(2:$, 2) - data(1:1237, 2);

extremes = [min(t_ia), max(t_ia)] // calcul du min et du max
moyenne = mean(t_ia)  // calcul de la moyenne
mediane = perctl(t_ia,50) // calcul de la mediane

// calcul de la variance et de l'écart-type
v = variance(t_ia)
s = stdev(t_ia)

// calcul de l'étendue
etendue = extremes(2) - extremes(1)

Q1 = perctl(t_ia, 25) // premier quartile
Q3 = perctl(t_ia, 75) // troisième quartile
IQ = Q3(1) - Q1(1) // intervalle interquartile
\end{verbatim}

\subsection{Fonction de répartition}
\begin{verbatim}
// Extraction des temps inter-arrivées
t_ia = data(2:$, 2) - data(1:1237, 2);

tab = tabul(t_ia, 'i'); // construction du tableau des effectifs
tab(:,2) = tab(:,2)/length(t_ia); // calcul des fréquences
F = cumsum(tab(:,2)); // calcul des fréquences cumulées
plot2d2(tab(:,1),F)
legend("Fonction de répartitions des temps interarrivés")

// Définition des paramètres d'affichages
a=gca();
a.x_location = "origin";
a.grid=[5,5];

\end{verbatim}

\subsection{Histogramme}
\subsubsection{Histogramme avec classes isoamplitudes}
\begin{verbatim}
// Extraction des temps inter-arrivées
t_ia = data(2:$, 2) - data(1:1237, 2);

C = linspace(min(t_ia), max(t_ia), 11) // calcul des classes

histplot(C, t_ia, style=2) // dessine l'histogramme
legend("Histogramme d isoamplitude des temps-interarrivés")
\end{verbatim}
\subsubsection{Histogramme avec classes isofréquences}
\begin{verbatim}
// Extraction des temps inter-arrivées
t_ia = data(2:$, 2) - data(1:1237, 2);

deciles=perctl(t_ia,10:10:90) // Calcul des déciles
// Affectations d'isofréquences comme bornes de classes
for i=2:10
    ClassesDeciles(i)=deciles(i-1)
end
ClassesDeciles(1)=min(t_ia)
ClassesDeciles(11)=max(t_ia)

histplot(ClassesDeciles,t_ia,style=2) // dessine l'histogramme
legend("Histogramme d isofréquences des temps-interarrivés")
\end{verbatim}

\section{Etude statistique des temps de service}

\subsection{Indicateurs de position et de dispersion}

\subsubsection{Serveur 1}
\begin{verbatim}
// Extraction des temps de service
index_bool = ( data(:, 3) = 1 )
tabS1 = data(index_bool, :)
t_s1 = tabS1(1:$,4)

extremesS1 = [min(t_s1), max(t_s1)] // calcul du min et du max
moyenneS1 = mean(t_s1)  // calcul de la moyenne
medianeS1 = perctl(t_s1,50) // calcul de la mediane

// calcul de la variance et de l'écart-type
vS1 = variance(t_s1)
sS1 = stdev(t_s1)

// calcul de l'étendue
etendueS1 = extremesS1(2) - extremesS1(1)

Q1S1 = perctl(t_s1, 25) // premier quartile
Q3S1 = perctl(t_s1, 75) // troisième quartile
IQS1 = Q3S1(1) - Q1S1(1) // intervalle interquartile
\end{verbatim}

\subsubsection{Serveur 2}
\begin{verbatim}
// Extraction des temps de service
index_bool = ( data(:, 3) = 2 )
tabs2 = data(index_bool, :)
t_s2 = tabs2(1:$,4)

extremesS2 = [min(t_s2), max(t_s2)] // calcul du min et du max
moyenneS2 = mean(t_s2)  // calcul de la moyenne
medianeS2 = perctl(t_s2,50) // calcul de la mediane

// calcul de la variance et de l'écart-type
vS2 = variance(t_s2)
sS2 = stdev(t_s2)

// calcul de l'étendue
etendueS2 = extremesS2(2) - extremesS2(1)

Q1S2 = perctl(t_s2, 25) // premier quartile
Q3S2 = perctl(t_s2, 75) // troisième quartile
IQS2 = Q3S2(1) - Q1S2(1) // intervalle interquartile
\end{verbatim}

\subsubsection{Serveur 3}
\begin{verbatim}
// Extraction des temps de service
index_bool = ( data(:, 3) = 3 )
tabS3 = data(index_bool, :)
t_s3 = tabS3(1:$,4)

extremesS3 = [min(t_s3), max(t_s3)] // calcul du min et du max
moyenneS3 = mean(t_s3)  // calcul de la moyenne
medianeS3 = perctl(t_s3,50) // calcul de la mediane

// calcul de la variance et de l'écart-type
vS3 = variance(t_s3)
sS3 = stdev(t_s3)

// calcul de l'étendue
etendueS3 = extremesS3(2) - extremesS3(1)

Q1S3 = perctl(t_s3, 25) // premier quartile
Q3S3 = perctl(t_s3, 75) // troisième quartile
IQS3 = Q3S3(1) - Q1S3(1) // intervalle interquartile
\end{verbatim}

\subsection{Fonctions de repartitions}

\subsubsection{Serveur 1}
\begin{verbatim}
// Extraction des temps de service

index_bool = ( data(:, 3) == 1 )
tabS1 = data(index_bool, :)
t_s1 = tabS1(1:$,4);

tab = tabul(t_s1,'i')
tab(:,2) = tab(:,2)/length(t_s1)
F = cumsum(tab(:,2))

plot2d2(tab(:,1),F)
legend("Fonction de répartitions des temps de service")

// Définition des paramètres d'affichages
a=gca();
a.x_location = "origin";
a.grid=[5,5];
\end{verbatim}

\subsubsection{Serveur 2}
\begin{verbatim}
// Extraction des temps de service

index_bool = ( data(:, 3) == 2 )
tabS1 = data(index_bool, :)
t_s1 = tabS1(1:$,4);

tab = tabul(t_s1,'i')
tab(:,2) = tab(:,2)/length(t_s1)
F = cumsum(tab(:,2))

plot2d2(tab(:,1),F)
legend("Fonction de répartitions des temps de service")

// Définition des paramètres d'affichages
a=gca();
a.x_location = "origin";
a.grid=[5,5];
\end{verbatim}

\subsubsection{Serveur 3}
\begin{verbatim}
// Extraction des temps de service

index_bool = ( data(:, 3) == 3 )
tabS1 = data(index_bool, :)
t_s1 = tabS1(1:$,4);

tab = tabul(t_s1,'i')
tab(:,2) = tab(:,2)/length(t_s1)
F = cumsum(tab(:,2))

plot2d2(tab(:,1),F)
legend("Fonction de répartitions des temps de service")

// Définition des paramètres d'affichages
a=gca();
a.x_location = "origin";
a.grid=[5,5];
\end{verbatim}

\subsection{Histogrammes}

\subsubsection{Serveur 1}
\begin{verbatim}
// Extraction des temps de service
index_bool = ( data(:, 3) == 1 )
tabS1 = data(index_bool, :)
t_s1 = tabS1(1:$,4);

deciles=perctl(t_s1,10:10:90);
for i=2:10
    ClassesDeciles(i)=deciles(i-1)
end
ClassesDeciles(1)=min(t_s1)
ClassesDeciles(11)=max(t_s1)

histplot(ClassesDeciles,t_s1,style=2)
legend("Histogramme d isofréquence du serveur 1")

// Définition des paramètres d'affichages
a=gca();
a.x_location = "origin";
a.grid=[5,5];
\end{verbatim}

\subsubsection{Serveur 2}
\begin{verbatim}
// Extraction des temps de service
index_bool = ( data(:, 3) == 2 )
tabS2 = data(index_bool, :)
t_s2 = tabS2(1:$,4);

deciles=perctl(t_s2,10:10:90);
for i=2:10
    ClassesDeciles(i)=deciles(i-1)
end
ClassesDeciles(1)=min(t_s2)
ClassesDeciles(11)=max(t_s2)

histplot(ClassesDeciles,t_s2,style=2)
legend("Histogramme d isofréquence du serveur 2")

// Définition des paramètres d'affichages
a=gca();
a.x_location = "origin";
a.grid=[5,5];
\end{verbatim}

\subsubsection{Serveur 3}
\begin{verbatim}
// Extraction des temps de service
index_bool = ( data(:, 3) == 3 )
tabS3 = data(index_bool, :)
t_s3 = tabS3(1:$,4);

deciles=perctl(t_s3,10:10:90);
for i=2:10
    ClassesDeciles(i)=deciles(i-1)
end
ClassesDeciles(1)=min(t_s3)
ClassesDeciles(11)=max(t_s3)

histplot(ClassesDeciles,t_s3,style=2)
legend("Histogramme d isofréquence du serveur 3")

// Définition des paramètres d'affichages
a=gca();
a.x_location = "origin";
a.grid=[5,5];
\end{verbatim}

\section{Ajustement graphique à des lois mathématiques}

\subsection{Tous les serveurs}

\subsubsection{Superposition des fonctions de répartitions}
\begin{verbatim}
// Extraction des temps inter-arrivées
t_ia = data(2:$, 2) - data(1:1237, 2);

tab = tabul(t_ia, 'i'); // construction du tableau des effectifs
tab(:,2) = tab(:,2)/length(t_ia); // calcul des fréquences
F = cumsum(tab(:,2)); // calcul des fréquences cumulées
plot2d2(tab(:,1),F)
legend("Fonction de répartitions des temps interarrivés")

// Définition des paramètres d'affichages
a=gca();
a.x_location = "origin";
a.grid=[5,5];

// Répartition loi normale
a=min(t_ia):0.01:max(t_ia)
m=ones(a)*mean(t_ia)
s=ones(a)*stdev(t_ia)
[P,Q]=cdfnor("PQ",a,m,s)
plot2d2(a,P,style=2)

// Repartition loi exponentielle
lambda=1/mean(t_ia)
b=1-exp(-lambda*a)
plot2d2(a,b,style=3)

// Repartition loi uniforme
c=(a-min(t_ia))/(max(t_ia)-min(t_ia))
plot2d2(a,c,style=4)

legend("Courbe de la fonction de répartition empirique","Courbe de la fonction 
de répartition de la loi normale","Courbe de la fonction de répartition de la 
exponentielle","Courbe de la fonction de répartition la loi uniforme")
\end{verbatim}

\subsubsection{Superposition des fonctions de densité et de l'histogramme}
\begin{verbatim}
// Extraction des temps inter-arrivées
t_ia = data(2:$, 2) - data(1:1237, 2);

// Histogramme
deciles=perctl(t_ia,10:10:90);
for i=2:10
    ClassesDeciles(i)=deciles(i-1)
end
ClassesDeciles(1)=min(t_ia)
ClassesDeciles(11)=max(t_ia)
histplot(ClassesDeciles,t_ia,style=2)

// Densité de la loi normale
a=min(t_ia):0.01:max(t_ia)
m=mean(t_ia)
v=stdev(t_ia)
b=(1/(v*sqrt(2*\%pi))*exp((-1/2)*((a-m)/v)^2))
plot2d2(a,b,style=1)

// Densité de la loi exponentielle
lambda=1/mean(t_ia)
b=lambda*exp(-lambda*a)
plot2d2(a,b,style=3)

// Densité de la loi uniforme
h=1/(max(t_ia)-min(t_ia))
b=ones(a)*h
plot2d2(a,b,style=20)

legend("Histogramme d isofréquence des temps interarrivés","Densité de la loi 
normale","Densité de la loi exponentielle","Densité de la loi uniforme")

// Définition des paramètres d'affichages
a=gca();
a.x_location = "origin";
a.grid=[5,5];
\end{verbatim}

\subsubsection{Propriété d'abscense de mémoire}
\begin{verbatim}
extremesS = [min(t_ia), max(t_ia)] // calcul du min et du max
moyenneS = mean(t_ia) // calcul de la moyenne
medianeS = perctl(t_ia,50) // calcul de la mediane
// calcul de la variance et de l'écart-type
vS = variance(t_ia)
sS = stdev(t_ia)
// calcul de l'étendue
etendueS = extremesS(2) - extremesS(1)
Q1S = perctl(t_ia, 25) // premier quartile
Q3S = perctl(t_ia, 75) // troisième quartile
IQS = Q3S(1) - Q1S(1) // intervalle interquartile

index_bool3 = (t_ia > 1)
tab_ia = t_ia(index_bool3)
new_t_ia = tab_ia - 1
extremes_ia = [min(new_t_ia), max(new_t_ia)] // calcul du min et du max
moyenne_ia = mean(new_t_ia) // calcul de la moyenne
mediane_ia = perctl(new_t_ia,50) // calcul de la mediane
// calcul de la variance et de l'écart-type
v = variance(new_t_ia)
e = stdev(new_t_ia)
// calcul de l'étendue
etendue = extremes_ia(2) - extremes_ia(1)
Q1_ = perctl(new_t_ia, 25) // premier quartile
Q3_ = perctl(new_t_ia, 75) // troisième quartile
IQ = Q3_(1) - Q1_(1) // intervalle interquartile

comparaison = [moyenne_ia - moyenneS, mediane_ia(1) - medianeS(1), v - vS, e - sS, etendue - etendueS]

subplot(1,2,1)
deciles=perctl(t_ia,10:10:90);
for i=2:10
    ClassesDeciles(i)=deciles(i-1)
end
ClassesDeciles(1)=min(t_ia)
ClassesDeciles(11)=max(t_ia)
histplot(ClassesDeciles,t_ia,style=2)
legend("Histogramme avec temps de service")

subplot(1,2,2)
histplot(ClassesDeciles,new_t_ia,style=1)
legend("Histogramme avec temps de services à partir de 1 seconde")
\end{verbatim}

\subsection{Serveur 1}

\subsubsection{Superposition des fonctions de répartitions}
\begin{verbatim}
// Extraction des temps de service

index_bool = ( data(:, 3) == 1 )
tabS1 = data(index_bool, :)
t_s1 = tabS1(1:$,4);

// Repartition empirique
tab = tabul(t_s1,'i')
tab(:,2) = tab(:,2)/length(t_s1)
F = cumsum(tab(:,2))

plot2d2(tab(:,1),F)

// Définition des paramètres d'affichages
a=gca();
a.x_location = "origin";
a.grid=[5,5];

// Répartition loi normale
a=min(t_s1):0.01:max(t_s1)
m=ones(a)*mean(t_s1)
s=ones(a)*stdev(t_s1)
[P,Q]=cdfnor("PQ",a,m,s)
plot2d2(a,P,style=2)

// Repartition loi exponentielle
lambda=1/mean(t_s1)
b=1-exp(-lambda*a)
plot2d2(a,b,style=3)

// Repartition loi uniforme
c=(a-min(t_s1))/(max(t_s1)-min(t_s1))
plot2d2(a,c,style=4)

legend("Courbe de la fonction de répartition empirique","Courbe de la fonction
de répartition de la loi normale","Courbe de la fonction de répartition de la 
exponentielle","Courbe de la fonction de répartition la loi uniforme")
\end{verbatim}

\subsubsection{Superposition des fonctions de densité et de l'histogramme}
\begin{verbatim}
// Extraction des temps de service
index_bool = ( data(:, 3) == 1 )
tabS1 = data(index_bool, :)
t_s1 = tabS1(1:$,4);

deciles=perctl(t_s1,10:10:90);
for i=2:10
    ClassesDeciles(i)=deciles(i-1)
end
ClassesDeciles(1)=min(t_s1)
ClassesDeciles(11)=max(t_s1)

histplot(ClassesDeciles,t_s1,style=2)

// Densité de la loi normale
a=min(t_s1):0.01:max(t_s1)
m=mean(t_s1)
v=stdev(t_s1)
b=(1/(v*sqrt(2*\%pi))*exp((-1/2)*((a-m)/v)^2))
plot2d2(a,b,style=1)

// Densité de la loi exponentielle
lambda=1/mean(t_s1)
b=lambda*exp(-lambda*a)
plot2d2(a,b,style=3)

// Densité de la loi uniforme
h=1/(max(t_s1)-min(t_s1))
b=ones(a)*h
plot2d2(a,b,style=20)

legend("Histogramme d isofréquence du serveur 1","Densité de la loi 
normale","Densité de la loi exponentielle","Densité de la loi uniforme")

// Définition des paramètres d'affichages
a=gca();
a.x_location = "origin";
a.grid=[5,5];
\end{verbatim}

\subsubsection{Propriété d'abscense de mémoire}
\begin{verbatim}
extremesS1 = [min(t_s1), max(t_s1)] // calcul du min et du max
moyenneS1 = mean(t_s1) // calcul de la moyenne
medianeS1 = perctl(t_s1,50) // calcul de la mediane
// calcul de la variance et de l'écart-type
vS1 = variance(t_s1)
sS1 = stdev(t_s1)
// calcul de l'étendue
etendueS1 = extremesS1(2) - extremesS1(1)
Q1S1 = perctl(t_s1, 25) // premier quartile
Q3S1 = perctl(t_s1, 75) // troisième quartile
IQS1 = Q3S1(1) - Q1S1(1) // intervalle interquartile

index_bool1 = (t_s1 > 1);
tab_s1 = t_s1(index_bool1);
new_t_s1 = tab_s1 - 1;
extremes1 = [min(new_t_s1), max(new_t_s1)] // calcul du min et du max
moyenne1 = mean(new_t_s1) // calcul de la moyenne
mediane1 = perctl(new_t_s1,50) // calcul de la mediane
// calcul de la variance et de l'écart-type
v1 = variance(new_t_s1)
e1 = stdev(new_t_s1)
// calcul de l'étendue
etendue1 = extremes1(2) - extremes1(1)
Q1_1 = perctl(new_t_s1, 25) // premier quartile
Q3_1 = perctl(new_t_s1, 75) // troisième quartile
IQ1 = Q3_1(1) - Q1_1(1) // intervalle interquartile

comparaison1 = [moyenne1 - moyenneS1, mediane1(1) - medianeS1(1), v1 - vS1, e1 - sS1, etendue1 - etendueS1]

subplot(1,2,1)
deciles=perctl(t_s1,10:10:90);
for i=2:10
    ClassesDeciles(i)=deciles(i-1)
end
ClassesDeciles(1)=min(t_s1)
ClassesDeciles(11)=max(t_s1)
histplot(ClassesDeciles,t_s1,style=2)
legend("Histogramme avec temps de service")

subplot(1,2,2)
histplot(ClassesDeciles,new_t_s1,style=1)
legend("Histogramme avec temps de services à partir de 1 seconde")
\end{verbatim}

\subsection{Serveur 2}

\subsubsection{Superposition des fonctions de répartitions}
\begin{verbatim}
// Extraction des temps de service

index_bool = ( data(:, 3) == 2 )
tabS2 = data(index_bool, :)
t_s2 = tabS2(1:$,4);

// Repartition empirique
tab = tabul(t_s2,'i')
tab(:,2) = tab(:,2)/length(t_s2)
F = cumsum(tab(:,2))

plot2d2(tab(:,1),F)

// Définition des paramètres d'affichages
a=gca();
a.x_location = "origin";
a.grid=[5,5];

// Répartition loi normale
a=min(t_s2):0.01:max(t_s2)
m=ones(a)*mean(t_s2)
s=ones(a)*stdev(t_s2)
[P,Q]=cdfnor("PQ",a,m,s)
plot2d2(a,P,style=2)

// Repartition loi exponentielle
lambda=1/mean(t_s2)
b=1-exp(-lambda*a)
plot2d2(a,b,style=3)

// Repartition loi uniforme
c=(a-min(t_s2))/(max(t_s2)-min(t_s2))
plot2d2(a,c,style=4)

legend("Courbe de la fonction de répartition empirique","Courbe de la fonction 
de répartition de la loi normale","Courbe de la fonction de répartition de la 
exponentielle","Courbe de la fonction de répartition la loi uniforme")
\end{verbatim}

\subsubsection{Superposition des fonctions de densité et de l'histogramme}
\begin{verbatim}
// Extraction des temps de service
index_bool = ( data(:, 3) == 2 )
tabS2 = data(index_bool, :)
t_s2 = tabS2(1:$,4);

deciles=perctl(t_s2,10:10:90);
for i=2:10
    ClassesDeciles(i)=deciles(i-1)
end
ClassesDeciles(1)=min(t_s2)
ClassesDeciles(11)=max(t_s2)

histplot(ClassesDeciles,t_s2,style=2)

// Densité de la loi normale
a=min(t_s2):0.01:max(t_s2)
m=mean(t_s2)
v=stdev(t_s2)
b=(1/(v*sqrt(2*\%pi))*exp((-1/2)*((a-m)/v)^2))
plot2d2(a,b,style=1)

// Densité de la loi exponentielle
lambda=1/mean(t_s2)
b=lambda*exp(-lambda*a)
plot2d2(a,b,style=3)

// Densité de la loi uniforme
h=1/(max(t_s2)-min(t_s2))
b=ones(a)*h
plot2d2(a,b,style=20)

legend("Histogramme d isofréquence du serveur 2","Densité de la loi 
normale","Densité de la loi exponentielle","Densité de la loi uniforme")

// Définition des paramètres d'affichages
a=gca();
a.x_location = "origin";
a.grid=[5,5];
\end{verbatim}

\subsubsection{Propriété d'abscense de mémoire}
\begin{verbatim}
extremesS2 = [min(t_s2), max(t_s2)] // calcul du min et du max
moyenneS2 = mean(t_s2) // calcul de la moyenne
medianeS2 = perctl(t_s2,50) // calcul de la mediane
// calcul de la variance et de l'écart-type
vS2 = variance(t_s2)
sS2 = stdev(t_s2)
// calcul de l'étendue
etendueS2 = extremesS2(2) - extremesS2(1)
Q1S2 = perctl(t_s2, 25) // premier quartile
Q3S2 = perctl(t_s2, 75) // troisième quartile
IQS2 = Q3S2(1) - Q1S2(1) // intervalle interquartile

index_bool2 = (t_s2 > 1)
tab_s2 = t_s2(index_bool2)
new_t_s2 = tab_s2 - 1
extremes2 = [min(new_t_s2), max(new_t_s2)] // calcul du min et du max
moyenne2 = mean(new_t_s2) // calcul de la moyenne
mediane2 = perctl(new_t_s2,50) // calcul de la mediane
// calcul de la variance et de l'écart-type
v2 = variance(new_t_s2)
e2 = stdev(new_t_s2)
// calcul de l'étendue
etendue2 = extremes2(2) - extremes2(1)
Q1_2 = perctl(new_t_s2, 25) // premier quartile
Q3_2 = perctl(new_t_s2, 75) // troisième quartile
IQ2 = Q3_2(1) - Q1_2(1) // intervalle interquartile

comparaison2 = [moyenne2 - moyenneS2, mediane2(1) - medianeS2(1), v2 - vS2, e2 - sS2, etendue2 - etendueS2]

subplot(1,2,1)
deciles=perctl(t_s2,10:10:90);
for i=2:10
    ClassesDeciles(i)=deciles(i-1)
end
ClassesDeciles(1)=min(t_s2)
ClassesDeciles(11)=max(t_s2)
histplot(ClassesDeciles,t_s2,style=2)
legend("Histogramme avec temps de service")

subplot(1,2,2)
histplot(ClassesDeciles,new_t_s2,style=1)
legend("Histogramme avec temps de services à partir de 1 seconde")
\end{verbatim}

\subsection{Serveur 3}

\subsubsection{Superposition des fonctions de répartitions}
\begin{verbatim}
// Extraction des temps de service

index_bool = ( data(:, 3) == 3 )
tabS3 = data(index_bool, :)
t_s3 = tabS3(1:$,4);

// Repartition empirique
tab = tabul(t_s3,'i')
tab(:,2) = tab(:,2)/length(t_s3)
F = cumsum(tab(:,2))

plot2d2(tab(:,1),F)

// Définition des paramètres d'affichages
a=gca();
a.x_location = "origin";
a.grid=[5,5];

// Répartition loi normale
a=min(t_s3):0.01:max(t_s3)
m=ones(a)*mean(t_s3)
s=ones(a)*stdev(t_s3)
[P,Q]=cdfnor("PQ",a,m,s)
plot2d2(a,P,style=2)

// Repartition loi exponentielle
lambda=1/mean(t_s3)
b=1-exp(-lambda*a)
plot2d2(a,b,style=3)

// Repartition loi uniforme
c=(a-min(t_s3))/(max(t_s3)-min(t_s3))
plot2d2(a,c,style=4)

legend("Courbe de la fonction de répartition empirique","Courbe de la fonction 
de répartition de la loi normale","Courbe de la fonction de répartition de la 
exponentielle","Courbe de la fonction de répartition la loi uniforme")
\end{verbatim}

\subsubsection{Superposition des fonctions de densité et de l'histogramme}
\begin{verbatim}
// Extraction des temps de service
index_bool = ( data(:, 3) == 3 )
tabS3 = data(index_bool, :)
t_s3 = tabS3(1:$,4);

deciles=perctl(t_s3,10:10:90);
for i=2:10
    ClassesDeciles(i)=deciles(i-1)
end
ClassesDeciles(1)=min(t_s3)
ClassesDeciles(11)=max(t_s3)

histplot(ClassesDeciles,t_s3,style=2)

// Densité de la loi normale
a=min(t_s3):0.01:max(t_s3)
m=mean(t_s3)
v=stdev(t_s3)
b=(1/(v*sqrt(2*%pi))*exp((-1/2)*((a-m)/v)^2))
plot2d2(a,b,style=1)

// Densité de la loi exponentielle
lambda=1/mean(t_s3)
b=lambda*exp(-lambda*a)
plot2d2(a,b,style=3)

// Densité de la loi uniforme
h=1/(max(t_s3)-min(t_s3))
b=ones(a)*h
plot2d2(a,b,style=20)

legend("Histogramme d isofréquence du serveur 3","Densité de la loi
normale","Densité de la loi exponentielle","Densité de la loi uniforme")

// Définition des paramètres d'affichages
a=gca();
a.x_location = "origin";
a.grid=[5,5];
\end{verbatim}

\subsubsection{Propriété d'abscense de mémoire}
\begin{verbatim}
extremesS3 = [min(t_s3), max(t_s3)] // calcul du min et du max
moyenneS3 = mean(t_s3) // calcul de la moyenne
medianeS3 = perctl(t_s3,50) // calcul de la mediane
// calcul de la variance et de l'écart-type
vS3 = variance(t_s3)
sS3 = stdev(t_s3)
// calcul de l'étendue
etendueS3 = extremesS3(2) - extremesS3(1)
Q1S3 = perctl(t_s3, 25) // premier quartile
Q3S3 = perctl(t_s3, 75) // troisième quartile
IQS3 = Q3S3(1) - Q1S3(1) // intervalle interquartile

index_bool3 = (t_s3 > 1)
tab_s3 = t_s3(index_bool3)
new_t_s3 = tab_s3 - 1
extremes3 = [min(new_t_s3), max(new_t_s3)] // calcul du min et du max
moyenne3 = mean(new_t_s3) // calcul de la moyenne
mediane3 = perctl(new_t_s3,50) // calcul de la mediane
// calcul de la variance et de l'écart-type
v3 = variance(new_t_s3)
e3 = stdev(new_t_s3)
// calcul de l'étendue
etendue3 = extremes3(2) - extremes3(1)
Q1_3 = perctl(new_t_s3, 25) // premier quartile
Q3_3 = perctl(new_t_s3, 75) // troisième quartile
IQ3 = Q3_3(1) - Q1_3(1) // intervalle interquartile

comparaison3 = [moyenne3 - moyenneS3, mediane3(1) - medianeS3(1), v3 - vS3, e3 - sS3, etendue3 - etendueS3]

subplot(1,2,1)
deciles=perctl(t_s3,10:10:90);
for i=2:10
    ClassesDeciles(i)=deciles(i-1)
end
ClassesDeciles(1)=min(t_s3)
ClassesDeciles(11)=max(t_s3)
histplot(ClassesDeciles,t_s3,style=2)
legend("Histogramme avec temps de service")

subplot(1,2,2)
histplot(ClassesDeciles,new_t_s3,style=1)
legend("Histogramme avec temps de services à partir de 1 seconde")
\end{verbatim}

%----------------------------------


\end{document}